---
title: "25.03.27 / SOLID 원칙"
excerpt: ""

categories:
  - Programming
  - C#
tags:
  - []

toc: true
toc_sticky: true

date: 2025-03-27
last_modified_at: 2025-04-29
---

SOLID 원칙은 객체 지향 프로그래밍에서 유지보수성과 확장성이 뛰어난 소프트웨어를 설계하기 위해 지켜야 할 다섯 가지 핵심 원칙을 가리킨다. SOLID는 다음 다섯 가지 원칙의 앞 글자를 딴 약어이다.

- 1\. 단일 책임 원칙 (Single Responsibility Principle, SRP)
- 2\. 개방-폐쇄 원칙 (Open/Closed Principle, OCP)
- 3\. 리스코프 치환 원칙 (Liskov Substitution Principle, LSP)
- 4\. 인터페이스 분리 원칙 (Interface Segregation Principle, ISP)
- 5\. 의존성 역전 원칙 (Dependency Inversion Principle, DIP)

각 원칙을 간략히 살표보자.

**단일 책임 원칙 (Single Responsibility Principle, SRP)**

- "클래스는 하나의 책임만 가져야 한다."
- 의미 : 클래스(또는 모듈)가 단 하나의 역할만 수행하도록 설계해야 한다.
- 중요성 : 만약 여러 기능이 한 클래스에 섞여 있다면, 그중 하나만 수정하려고 해도 클래스 전체를 수정해야 하는 상황이 생겨 유지보수가 어려워진다.
- 예시
  - '사용자 관리' 기능과 '메일 전송' 기능을 한 클래스에서 처리한다면, 메일 전송 로직을 변경할 때 사용자 관리 코드가 엮여 있어 영향을 받게 된다.
  - 이를 분리해 'UserManager'와 'EmailService'로 나누면, 각각의 클래스는 독립적으로 동작하므로 변경 범위가 줄어든다.

**개방-폐쇄 원칙 (Open/Closed Principle, OCP)**

- "소프트웨어 요소(클래스, 메소드 등)는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다."
- 의미 : 기존 코드를 직접 수정하지 않고도 기능을 확장할 수 있도록 만들어야 한다.
- 중요성 : 코드 변경 없이 새로운 기능이나 요구 사항을 수용할 수 있으면 유지보수 비용이 크게 줄어든다.
- 구현 방법
  - 추상화(인터페이스, 추상 클래스)를 이용하여 다양한 구현체를 쉽게 추가/확장할 수 있도록 설계한다.
  - 예시로, IShape 인터페이스에 Draw() 메소드를 정의해두고, Circle, Rectangle 등 구체 클래스가 이를 구현하게 하면, 새로운 도형을 추가하더라도 기존 코드는 수정 없이도 처리할 수 있게 된다.

**리스코프 치환 원칙 (Liskov Substitution Principle, LSP)**

- "서브 타입은 언제나 자신의 베이스 타입으로 교체할 수 있어야 한다."
- 의미 : 자식 클래스는 부모 클래스의 계약(Constract)에 위배되지 않도록 행동해야 한다.
- 중요성 : 다형성(Polymorphism)을 사용하는 클래스 구조에서, 자식 클래스가 부모 클래스의 예상 동작을 깨뜨리면 예기치 않은 버그가 발생한다.
- 예시
  - Rectangle 클래스와 이를 상속한 Square 클래스가 있다고 하자.
  - Square는 가로/세로 길이가 같아야 하는 특수한 사각형이므로, Rectangle의 SetWidth(), SetHeight() 메소드를 그대로 두면 Square의 정의와 충돌이 생길 수 있다(width != height가 되어버리는 상황).
  - 이처럼 부모 클래스가 예상하는 행동(가로/세로를 독립적으로 변경 가능)과 자식 클래스가 가진 실제 특성(가로/세로가 동일해야 함)이 충돌하면, LSP에 어긋난다.
  - 따라서, 설꼐 초기 단계에서 Square가 Rectangle을 상속받는 구조가 적절한지 다시 고려해야 한다.

**인터페이스 분리 원칙 (Interface Segregation Principle, ISP)**

- "클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺지 않아야 한다."
- 의미 : 인터페이스를 작고 명확한 단위로 분리해, 사용하지 않는 기능에 대한 의존이 생기지 않도록 해야 한다.
- 중요성 : 인터페이스가 방대해지면 실제로는 사용하지 않는 메소드까지 구현해야 하므로, 변경에도 불필요하게 영향을 받게 된다.
- 예시
  - '출력' 기능만 필요한 클래스가 큰 IAllInOnePrinter(스캔, 팩스, 복사 등 모든 기능이 정의된 인터페이스)를 구현해야 한다면, 필요없는 메소드도 전부 구현해야 한다.
  - 이를 IPrinter, IScanner, IFAx 등 작은 인터페이스로 나누면, 정말 필요한 기능만 구현하면 되므로 훨씬 유연해진다.

**의존성 역전 원칙 (Dependency Inversion Principle, DIP)**

- "추상(인터페이스)에 의존해야지, 구체(구현 클래스)에 의존하면 안 된다."
- 의미 : 상위(추상) 모듈과 하위(구현) 모듈 간의 의존 관계를 역전시켜, 구체적인 구현이 아니라 추상화된 계약(인터페이스, 추상 클래스)에 의존하도록 설계해야 한다.
- 중요성 : 구체적인 클래스를 직접 참조하면 클래스 간 결합도가 높아져, 변경에 취약해진다.
- 예시
  - OrderService가 KakaoPayment 같은 특정 결제 클래스에 직접 의존하면, 결제 로직을 변경(Paypal, NaverPay 등)할 때 OrderService 내부 코드를 수정해야 한다.
  - '결제'라는 추상 인터페이스(IPayment)를 만들어 OrderService는 이를 통해 결제를 처리하고, KakaoPayment, Paypal 등은 이 인터페이스를 구현하기만 하면 OrderService는 변화 없이 새로운 결제 방식을 수용할 수 있다.

결과적으로 SOLID 원칙은 객체 지향 설계의 지향점인 낮은 결합도, 높은 응집도를 구현하기 위한 구체적인 가이드라인으로 볼 수 있다. SOLID 원칙이 중요한 이유는 유지보수성 향상, 확장성 증가, 재사용성 보장, 테스트 용이성의 향상이 있다. 항상 보는 그 장점들이긴 하다. 그 만큼 중요하니까 강조하는 것이니까 꼭 유념하도록 하자.
