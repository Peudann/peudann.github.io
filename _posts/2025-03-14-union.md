---
title: "25.03.14 / 유니온(Union)"
excerpt: ""

categories:
  - Programming
  - Data Structure and Algorithm
tags:
  - []

toc: true
toc_sticky: true

date: 2025-03-14
last_modified_at: 2025-04-25
---

아래는 유니온을 정의한 예시이다.

```c
union Data {
    int   i;
    float f;
    char  c;
};
```

저번 글에서 봤던 구조체와 거의 비슷하게 생겼다. 그럼 유니온은 구조체와 어떤 차이를 지닐까? 한 번 실행시켜보자.

```c
#include <stdio.h>

union Data {
    int   i;
    float f;
    char  c;
};

int main() {
    union Data data;

    data.i = 100;
    printf("data.i = %d\n", data.i);  // 100
    printf("data.f = %f\n", data.f);  // 같은 메모리를 float로 해석
    printf("data.c = %c\n", data.c);  // 같은 메모리를 char로 해석

    data.f = 3.14f;
    printf("data.i = %d\n", data.i);  // 같은 메모리를 int로 해석
    printf("data.f = %f\n", data.f);  // 3.140000
    printf("data.c = %c\n", data.c);  // 같은 메모리를 char로 해석

    return 0;
}
```

```text
실행 결과

data.i = 100
data.f = 0.000000
data.c = d

data.i = 1078523331
data.f = 3.140000
data.c = �	// 글자 깨짐
```

이렇게 출력해보면 멤버 하나의 값을 바꿀 때마다 다른 것들도 값이 바뀐다. 이렇게 되는 이유는 유니온의 모든 멤버는 메모리를 공유하기 때문이다. 여러 멤버를 묶어 하나의 사용자 정의 타입을 만드는 건 구조체와 같지만, 구조체와 달리 유니온의 모든 멤버는 같은 메모리를 공유한다. 즉, 유니온의 전체 크기는 가장 큰 멤버의 크기에 의해 결정되고, 모든 멤버는 해당 메모리 영역을 겹쳐 사용한다는 것이다.

int, float, char 멤버가 존재하지만 이들은 같은 메모리 공간 위에 배치된다. int가 4바이트, float가 4바이트, char가 1바이트라 유니온 Data의 크기는 4바이트가 된다(컴파일러/플랫폼에 따라 정렬 때문에 추가 패딩이 들어가는 경우도 있다).

위 코드에서 data.i = 100을 설정하고 data.f나 data.c를 출력하면, 실제로 같은 바이트 영역을 다른 자료형으로 해석하기 때문에 우리가 의도한 숫자와 전혀 다른 값이 찍힌다. 이런 특성을 타입 변환 없이 메모리 내용을 직접 공유해야 할 때, 예를 들어 디바이스 제어, 네트워크 패싯 파킹, 시스템 레벨 프로그래밍 등을 할 때 종종 유용하게 활용할 수 있다.

구조체와 유니온의 차이점을 표로 정리하고 글 마무리 하도록 하겠다.

| 구분        | 구조체 (Struct)                                                      | 유니온 (Union)                                                                        |
| ----------- | -------------------------------------------------------------------- | ------------------------------------------------------------------------------------- |
| 메모리 구조 | 각 멤버마다 고유의 메모리 공간이 확보됨                              | 모든 멤버가 동일한 메모리 공간을 겹쳐서 사용                                          |
| 크기        | 각 멤버 크기의 합 + 패딩(정렬로 인한 추가 바이트)                    | 가장 큰 멤버의 크기 + 정렬로 인한 패딩 존재 가능                                      |
| 사용 의도   | 여러 멤버들을 동시에 저장, 사용해야 할 때                            | 여러 자료형을 하나의 메모리 공간에서 서로 다른 시점에 사용해야 할 때                  |
| 멤버 접근   | 모든 멤버에 독립적으로 접근 가능                                     | 한 시점에 한 멤버만이 유효 기타 멤버는 같은 공간에 덮어써지므로 무효화됨              |
| 활용 예시   | 일반적인 데이터 구조(예: 회원 정보, 좌표, 학생 성적), 엔티티 정의 등 | 하드웨어 레지스터 접근, 네트워크 패킷/데이터 파싱, 서로 다른 타입 간의 메모리 변환 등 |
