---
title: "25.03.26 / Deadly Diamond"
excerpt: ""

categories:
  - Programming
tags:
  - []

toc: true
toc_sticky: true

date: 2025-03-26
last_modified_at: 2025-04-29
---

<div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
  <img src="/assets/img/250326_deadlyDiamond/01.png" alt="01" style="max-width: 100%;" />
</div>

객체 지향 프로그래밍에서 흔히 말하는 죽음의 다이아몬드 문제는 다중 상속에서 발생할 수 있는 대표적인 문제 중 하나다. 이 문제는 부모클래스가 겹치는 형태의 다중 상속 구조를 사용할 때 나타난다.

위의 그림처럼 A라는 클래스가 있고, 클래스 B와 클래스 C가 각각 A를 상속받는다. 그리고 클래스 D가 B와 C를 상속받는다. 이러한 구조가 다이아몬드 모양과 비슷하다고 하여 다이아몬드 상속 구조라고 부른다. 이때 B와 C가 같은 상위 클래스 A를 중복으로 상속받고 있기 때문에, D 입장에서는 '어떤 경로로 물려받은 A를 사용해야 하는가'라는 문제가 발생한다.

문제의 증상에는 아래가 있다.

- 1\. 중복 정의(Ambiguous Call)
  - B와 C 모두 A의 메소드 혹은 멤버 변수를 사용할 때, D가 이를 호출하면 컴파일러가 'A의 동일한 메소드가 두 개 있어 어느 쪽을 써야 할지 모르겠다'와 같은 모호성 에러를 낼 수 있다.
- 2\. 반복된 초기화
  - C++같은 언어에서 다중 상속 시 각 경로마다 상위 클래스가 따로 초기화된다면, A의 생성자나 소멸자가 불필요하게 여러 번 호출되는 문제가 생길 수있다.
- 3\. 코드 가독성 및 유지 보수성 저하
  - 다중 상속 자체만으로도 코드 구조가 복잡해지는데, 그 중 다이아몬드 구조가 나타나면 클래스 사이의 관계가 얽히면서 문제가 생기기 쉬워지고, 유지보수가 힘들어진다.

이를 해결하기 위해 언어들은 여러 접근 방식을 가지고 있다.

C++의 경우 다중 상속을 지원하기 때문에, 위에서 언급한 문제를 해결하기 위해 virtual base class를 제공하여, 상속 구조에서 겹치는 베이스 클래스를 가상 베이스 클래스로 만들면, 해당 베이스 클래스의 인스턴스가 중복으로 생성되지 않도록 관리할 수 있다. 이런 방법을 통해 모호성을 제거하고 중복 초기화를 방지한다.

Java와 C#의 경우 클래스를 통한 다중 상속을 직접 지원하지 않지만, 인터페이스를 통한 다중 구현은 가능하다. 이는 다이아몬드 문제 자체를 언어 차원에서 원천적으로 막고, 모호성 문제는 인터페이스 디폴트 메소드에서만 조정하여 해결하는 방식이다.

여러 객체지향 프로그래밍 언어들이 다중 상속 대신 믹스인(Mix-In) 또는 트레이트(Trait) 같은 다른 형태를 제공함으로써, 하나의 베이스 클래스를 여러 경로에서 중복 상속받음으로 발생하는 복잡도를 피하려한다.

다중 상속은 강력한 기능이지만, 잘못 사용하면 코드가 복잡해지고 유지보수가 어려워지므로 신중한 설계와 사용이 필요하겠다.
