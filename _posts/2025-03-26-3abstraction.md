---
title: "25.03.26 / 추상화(Abstraction)"
excerpt: ""

categories:
  - Programming
  - C#
tags:
  - []

toc: true
toc_sticky: true

date: 2025-03-26
last_modified_at: 2025-04-29
---

추상적이라는게 무슨 뜻일까? 추상적이란 건 '어떤 사물이 직접 경험하거나 지각할 수 있는 일정한 형태와 성질을 갖추고 있지 않은, 혹은 구체성이 없이 사실이나 현실에서 멀어져 막연하고 일반적인' 이라는 뜻이다. 그러니까 쉽게 말해서 구체적이지 못하고 그냥 막연하다는 거다.

지나가는 자동차를 보며 생각해보자. 이 자동차는 B사의 무슨 모델이고 바퀴가 몇 개고, 문이 몇 개고, 엔진이 전기 엔진이고... 처럼 구체적인 특징이 있을 것이다. 반대로 추상적으로 생각해보면 이건 B사의 특정 모델이지만 4륜차에 속하고, 이동 수단에 속하고, 전체적으로 보면 기계에 속하고, 뭐 이런 식으로 점점 넓은 범위로 생각을 넓혀가면 추상적으로 생각할 수 있는 것이다.

그럼 객체지향 프로그래밍에선 추상화가 무슨 장점이 있길래 그렇게 추상화를 강조하는 걸까?

우선 추상화의 주요 특징을 알아보자.

- 1\. 복잡성 감소
  - 사용자는 객체가 제공하는 기능(인터페이스)만 알고 있으면 되므로, 내부 구현(어떻게 동작하는지)에는 신경 쓸 필요가 없다.
  - 추상화 덕분에 시스템 설계 시 필요한 정보만 다루게 되어 복잡도가 크게 줄어든다.
- 2\. 유연성 향상
  - 추상화된 인터페이스(예를 들어 추상 클래스나 인터페이스)를 사용하면, 구체적인 구현이 바뀌더라도 인터페이스는 동일하게 유지된다.
  - 이러한 구조는 다형성을 높이고, 코드의 재사용성과 확장성을 강화한다.
- 3\. 코드 재사용성 증가
  - 추상 클래스를 통해 기본 뼈대를 정의한 뒤, 구체적인 세부 동작(메소드 구현 등)은 하위 클래스들이 담당한다.
  - 상위 클래스에서 정의해둔 추상 메소드나 속성은 여러 하위 클래스에서 재사용할 수 있어, 중복 코드를 줄일 수 있다.
- 4\. 보안성 및 캡슐화와의 시너지
  - 추상화는 객체지향의 또 다른 핵심 원칙인 캡슐화(Encapsulation)와 밀접한 관련이 있다.
  - 내부 로직이 직접 노출되지 않아, 외부에서 함부로 접근하거나 수정하기 어려워지고, 유지 보수 시 안정성이 높아진다.
- 5\. 확장성(유지 보수성) 향상
  - 추상화 계층(추상 클래스, 인터페이스 등)이 있으면, 새 기능을 추가하거나 기존 코드를 수정할 때 해당 계층만 건드려도 되므로 수정 범위가 줄어든다.
  - 팀 프로젝트에서도 추상화된 인터페이스에 맞춰 각자 구현을 진행하기 좋다.

간단한 예시를 들어보겠다. 예를 들어 Animal이라는 추상 클래스에 MakeSound라는 추상 메소드를 정의했다고 해보자.

```csharp
abstract class Animal
{
    public abstract void MakeSound();
}
```

이제 Animal을 상속받으며, MakeSound()를 각자 다르게 가지는 Dog와 Cat을 만들어보자.

```csharp
class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Bark!");
    }
}

class Cat : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Meow!");
    }
}
```

Dog는 Bark!, Cat은 Meow!를 출력하게 됐다. 이렇게 하면 new Dog(), new Cat()과 같이 실재 객체는 하위 클래스로 생성하되, 변수 타입은 추상 클래스인 Animal로 선언할 수 있다.

```csharp
public class Program
{
    public static void Main()
    {
        Animal dog = new Dog();
        Animal cat = new Cat();

        dog.MakeSound(); // "Bark!"
        cat.MakeSound(); // "Meow!"
    }
```

각자의 MakeSound 메소드를 호출하면 실제 객체 타입(Dog, Cat)에 맞는 메소드가 동작한다.

코드를 사용하는 입장에서는 '동물이 소리를 낸다'라는 큰 틀(추상화)에만 의존하며, 실제로 어떤 소리가 나는지는 구체적인 클래스(하위 클래스)에서 결정하게 된다.

이처럼 추상화는 객체 지향 프로그래밍에서 복잡도를 낮추고, 코드 구조를 더욱 견고하고 유연하게 만들어 주는 핵심 개념이다. 한번 바깥을 걸어다니면서 보이는 것들을 추상적으로 생각해보는 시간을 가져보는 건 어떨까?
