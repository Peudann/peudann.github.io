---
title: "25.03.28 / 인터페이스(Interface)"
excerpt: ""

categories:
  - Programming
  - C#
tags:
  - []

toc: true
toc_sticky: true

date: 2025-03-28
last_modified_at: 2025-04-29
---

인터페이스가 무엇인지 설명하기 전에, 인터페이스가 어떻게 생겼는지 알아보자. 인터페이스는 다음과 같이 interface 키워드를 이용해 선언한다.

```text
interface 인터페이스_이름
{
    반환_형식 메소드_이름1(매개변수_목록);
    반환_형식 메소드_이름2(매개변수_목록);
    반환_형식 메소드_이름3(매개변수_목록);
   	...
}
```

직접보니 클래스를 선언하는 것과 비슷하게 생겼다. 일견 인터페이스의 선언은 클래스의 그것과 비슷해 보이지만, 메소드, 이벤트, 인덱서, 프로퍼티만을 가질 수 있다는 차이가 있다. 인터페이스의 실제 선언 예는 다음과 같다.

```csharp
interface ILogger
{
    void WriteLog(string _message);
}
```

인터페이스는 메소드, 이벤트, 인덱서, 프로퍼티만 가질 수 있는데 그나마도 구현부가 없다. 이상한 점은 그뿐만이 아니다. 클래스는 접근 제한 지정자로 수식하지 않으면 기본적으로 private로 선언되지만, 인터페이스는 접근 제한 한정자를 사용할 수 없고 모든 것이 public으로 선언된다. 게다가 인터페이스는 인스턴스도 만들 수가 없다.

그럼 이런 걸 어디에 쓰는가에 대한 의문이 생길 수도 있다. 인터페이스는 인스턴스를 가질 수 없지만, 이 인터페이스를 상속받는 클래스의 인스턴스를 만드는 것은 가능하다. 물론 이때도 규칙이 있는데, 파생 클래스는 인터페이스에 선언된 모든 메소드 및 프로퍼티를 구현해줘야 하며, 이 메소드들은 public 한정자로 수식해야 한다. 다음은 위의 ILogger 인터페이스를 상속받는 파생 클래스의 예시이다.

```csharp
class ConsoleLogger : ILogger
{
    public void WriteLog(string _message)
    {
        Console.WriteLine("{0} {1}", DataTime.Now.ToLocalTime(), _message);
    }
}
```

이와 같이 선언한 클래스는 다음과 같이 인스턴스화 가능하다.

```csharp
ILogger logger = new ConsoleLogger();
logger.WriteLog("Hello, World!");
```

이 코드에 나타난 것처럼 인터페이스는 인스턴스를 만들지 못하지만, 참조는 만들 수 있다. 이 참조에서 파생 클래스의 객체의 위치를 담는 것이다. 파생 클래스는 기반 클래스와 같은 형식으로 간주하는데, 이것은 인터페이스로부터 상속받는 클래스의 관계에도 그대로 적용된다. 즉, ConsoleLogger의 객체는 ILogger의 객체로 취급할 수 있다는 이야기이다.

인터페이스 선언에 관련된 C# 문법은 이 정도가 거의 전부라고 할 수 있다. 그럼 이제 특징과 장점들을 알아보자.

- 인터페이스의 특징
  - 1\. 구현(Implementation)보다는 사용(Usage)에 초점
    - 인터페이스는 "어떠한 동작이 필요하다"는 것을 지정하지만, 그 동작이 "어떻게 실행되는지"는 전혀 다루지 않는다. 즉, 클래스끼리의 상호 작용 시 규약을 정하는 역할을 한다.
  - 2\. 다중 구현(Multipple Implementation)
    - 일반적으로 클래스는 여러 개의 인터페이스를 동시에 구현할 수 있다.
    - 예를 들어, 자바에서 한 클래스가 interface A와 interface B를 동시에 implements 할 수 있다.
  - 3\. 표준화(Consistency)와 확장성(Extensibility)
    - 인터페이스가 미리 정의된 메소드들을 통해 공통된 형태의 기능을 요구하므로, 표준화된 접근 방식을 제공한다.
    - 또한, 새로운 클래스가 추가되더라도 기존에 정의된 인터페이스를 구현하기만 하면 시스템에 쉽게 결합할 수 있어, 확장성이 좋아진다.
  - 4\. 결합도(Coupling) 감소
    - 특정 구현체가 아닌 '인터페이스'에 의존하도록 코드를 구성하면, 클래스 간 결합도가 낮아진다.
    - 예를 들어, "어떤 기능이 필요하다"는 점만 알면 되고, 실제 구현 내용이 어떻게 되어 있는지는 몰라도 되므로 모듈 간 독립성이 올라간다.
- 인터페이스와 추상 클래스의 차이
  - 추상 클래스(Abstract Class)
    - 추상 메소드(구현부가 없는 메소드)와 구체 메소드(구현부가 있는 메소드)를 혼합해 포함할 수 있다.
    - 보통 IS-A 관계(상속)에서 사용한다.
    - 멤버 변수(필드)를 가질 수 있고, 생성자도 존재할 수 있다.
  - 인터페이스(Interface)
    - 메소드 시그니처만 선언하며, 구현은 없다.
    - 보통 CAN-DO 관계(행동 보장)에서 사용한다.
    - 일반적으로 상태(멤버 변수)를 가지지 않으며, 오직 상수만 가질 수 있는 경우가 많다.

```csharp
using System;

namespace InterfaceExample
{
    // 1. 인터페이스 선언
    public interface IAnimal
    {
        void Eat();
        void Move();
    }

    // 2. 인터페이스 구현 (Dog 클래스)
    public class Dog : IAnimal
    {
        public void Eat()
        {
            Console.WriteLine("개가 사료를 먹습니다.");
        }

        public void Move()
        {
            Console.WriteLine("개가 뛰어다닙니다.");
        }
    }

    // 3. 인터페이스 구현 (Fish 클래스)
    public class Fish : IAnimal
    {
        public void Eat()
        {
            Console.WriteLine("물고기가 작은 먹이를 먹습니다.");
        }

        public void Move()
        {
            Console.WriteLine("물고기가 헤엄칩니다.");
        }
    }

    // 4. 테스트
    class Program
    {
        static void Main(string[] args)
        {
            IAnimal dog = new Dog();
            dog.Eat();    // "개가 사료를 먹습니다."
            dog.Move();   // "개가 뛰어다닙니다."

            IAnimal fish = new Fish();
            fish.Eat();   // "물고기가 작은 먹이를 먹습니다."
            fish.Move();  // "물고기가 헤엄칩니다."
        }
    }
}
```

이 예시에서, IAnimal이라는 인터페이스는 Eat()과 Move() 메소드를 반드시 구현하도록 강제한다. Dog와 Fish 클래스는 각각 IAnimal 인터페이스를 구현하여, 자신만의 구체적인 동작(메소드 내용)을 제공한다. Main() 메소드에서 보듯, IAnimal 타입 변수로 다양한 구현체(Dog, Fish)를 동일한 방식으로 다룰 수 있다.

- 사용 목적과 장점
  - 1\. 다형성(Polymorphism) 구현
    - 같은 인터페이스를 구현한 여러 클래스가 있으면, 인터페이스 타입 하나로 다양한 객체들을 다룰 수 있다.
    - 예를 들어, Animal 타입의 매개변수로 Dog, Fish 등을 모두 전달 가능.
  - 2\. 유연한 구조(Decoupled Design)
    - 클래스 간 결합도를 낮추고, 서로 독립적인 개발이 용이하도록 한다.
  - 3\. 메시지 기반 설계
    - "무엇을 할 수 있는가?"에 집중해, 객체들이 주고받는 메시지를 중심으로 프로그램을 설계할 수 있다.
  - 4\. 유닛 테스트 및 유지보수 용이
    - 인터페이스를 통해 모의 객체를 주입하여 테스트하기 쉬우며, 구현체 교체가 자유로워 유지보수가 편해진다.

정리해보자면, 인터페이스는 클래스에게 특정 기능을 반드시 구현하도록 요구하는 "규약"이며, 구체적인 구현 내용을 담지 않는다. 이로 인해 결합도는 낮추고, 유연성과 확장성은 높이는 효과가 있다. 객체지향 원칙 중 하나인 다형성을 간단히 구현할 수 있는 핵심 수단 중 하나다.

인터페이스를 잘 활용하면 개방-폐쇄 원칙(Open-Closed Principle, OCP)과 같은 객체지향 설계 원칙을 지키기 쉬워지고, 코드를 보다 모듈화하고 유지보수하기 쉬워진다.
