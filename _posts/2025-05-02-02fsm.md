---
title: "25.05.02 / Finite State Machine, Subsumption Architecture(포섭 아키텍처)"
excerpt: ""

categories:
  - Programming
  - Game Development
tags:
  - []

toc: true
toc_sticky: true

date: 2025-05-02
last_modified_at: 2025-05-08
---

### **1\. Finite State Machine (유한 상태 기계)**

#### **1) 개념**

- **정의**\\
유한한 개수의 **상태(State)**를 가지며, 특정 **조건(입력)**에 따라 상태 간 전이(Transition)가 일어나는 **상태 머신(State Machine)** 구조이다.

- **구성 요소**
  - **상태(State)**: 현재 AI(또는 오브젝트)가 놓인 국면을 나타낸다. (예: Idle, Walk, Attack 등)
  - **전이(Transition)**: 어떤 조건(입력)이 충족되면 한 상태에서 다른 상태로 넘어가는 규칙이다.
  - **입력(Input)/이벤트(Event)**: 상태 전이의 조건을 만족시키는 트리거(Trigger)이다.

#### **2) 사용 맥락(게임/AI)**

- **NPC 행동 제어**: 적 캐릭터가 "대기->추적->공격->재정비"와 같은 일련의 로직을 진행할 때 상태 머신이 자주 쓰인다.
- **디자인 패턴**: FSM은 객체 지향적으로 구현할 때 "State" 패턴과도 유사하며, **상태별 로직을 분리**하여 관리할 수 있다.
- **장점**: 구현이 간단하고, 상태와 전이 조건을 명시적으로 다루므로 로직이 명확해진다.
- **단점**: 상태가 많아지면 전이 규칙이 급격히 복잡해질 수 있다.

---

### **2\.Stack-Based FSM**

#### **1) 개념**

- **정의**\\
기본적인 FSM을 확장한 구조로, **스택 자료구조**를 이용해 여러 상태를 쌓아두고 필요할 때 Push/Pop하며 제어하는 상태 머신이다.

- **동작 방식**
  - **Push**: 새 상태가 필요할 때 스택 위에 새로운 상태를 올려놓는다.
  - **Pop**: 현재 상태를 종료해야 하거나 이전 상태로 돌아가야 할 때 스택에서 상태를 꺼낸다.
  - **Top of Stack**: 스택 최상단의 상태만이 활성(Active) 상태로 동작하며, 게임 오브젝트는 해당 상태의 로직을 수행한다.

#### **2) 사용 이유**

- **상태 중첩**\\
예를 들어, 캐릭터가 Idle -> 피해를 받음(Hit) -> 다시 Idle로 복귀해야 할 때, 단순 FSM은 상태 전이 규칙이 많이 필요하다. 반면 Stack-Base FSM이면 현재 Idle 상태를 유지한 채 Hit 상태를 **임시로 덮어쓰고**, 해당 상태가 끝나면 Pop하여 Idle로 돌아올 수 있다.

- **순환 구조 간소화**\\
임시적인 행동(메뉴 열기, 일시정지, 컷신 재생 등)을 수행했다가 쉽게 복귀해야 하는 경우 유리하다.
  - 예: 게임 플레이(최상위 FSM) 중 메뉴 화면을 열어야 하면 Push(Menu 상태) -> 메뉴 종료시 Pop(Menu 상태).

#### **3) 특징**

- **장점**
  - 간단한 전이(Transition)만으로 여러 상태를 자유롭게 중첩/복귀 가능
  - 임시 상태를 처리하기에 편리

- **단점**
  - 무분별하게 많은 상태를 쌓으면 스택 관리가 복잡해질 수 있음
  - 일반적인 FSM보다 메모리/구조가 조금 더 복잡함

---

### **3\. Subsumption Architecture(포섭 아키텍처)**

#### **1) 개념**

- **정의**\\
로봇 공학자 **Rodney Brooks**가 제안한 구조로, **여러 계층(Layer)**로 나눈 단순한 행동(Behavior)들이 **병렬**로 동작하며, **상위 계층이 하위 계층의 행동을 '포섭(Subsume)'**하는 방식의 아키텍처이다.

- **핵심 아이디어**
  1. **단순 행동**부터 설계: 예) 충돌 방지, 벽 따라가기 등
  2. **상위 계층**은 하위 계층보다 **우선순위**가 높음
  3. 상위 계층의 행동이 필요 없을 때는 하위 계층의 행동이 그대로 동작
  4. 상위 계층이 간섭할 필요가 있을 때, 하위 계층을 억제하거나 우선순위를 바꿈

- **예시**
  - 레이어 1(기본 안전 행동): 장애물에 가까이 가면 멈춘다.
  - 레이어 2(탐색 행동): 탐색해야 할 목표 지점이 있으면 장애물 회피를 하면서 이동한다.
  - 레이어 3(전투 행동): 적이 나타나면 공격 행동을 우선순위로 수행하며, 필요시 이동∙회피 명령을 하위 계층에 던지거나 하위 계층을 억제한다.

#### **2) 게임에서의 활용**

- **NPC AI 설계**: 낮은 레벨의 '기본 생존 행동(벽에 부딪히지 않기, 추락 방지)'을 항상 켜 두고, 그 위에 '탐색 AI', 또 그 위에 '전투 AI' 등 **레이어**를 층층이 쌓아 구성할 수 있다.

- **장점**
  - 모듈화된 구조: 각 레이어별로 단순 로직을 구현하고, 우선순위(포섭)에 따라 제어하므로 디버그가 쉬움
  - 반응형 행동(Reactive Behavior) 구현이 용이

- **단점**
  - 제대로 된 포섭 로직(억제∙우선순위 조정)을 설계하지 않으면 충돌이 발생하거나 예상치 못한 동작이 나올 수 있음
  - 레이어가 많아지면 우선순위 관리가 복잡해질 수 있음

---

### **4\. 세 가지 구조의 연관성**

#### **1\. Finite State Machine(FSM)**
- 가장 기초적인 상태 기반 제어 구조.
- 대부분의 간단한 NPC AI나 메뉴 시스템, UI 흐름 등에 폭넓게 사용.

#### **2\. Stack-Based FSM**
- FSM을 확장하여 **'이전 상태로 돌아가기'**가 쉬운 구조를 제공.
- 임시 상태 전환이 잦은 게임(메뉴, 컷신, 일시정지) 혹은 캐릭터 행동(잠깐 피해 받았다가 다시 원래 행동으로 복귀) 등에서 편리.

#### **3\. Subsumption Architecture**
- FSM처럼 **'상태'**라기보다는, **레이어별**로 동작하는 **'행동(Behavior)'** 구조.
- 상∙하위 계층이 동시에 구동되며, 상위 계층이 하위 계층을 '억제' 혹은 '재정의'하는 방식을 취함.
- 로봇 공학에서 주로 시작되었지만, 게임 AI에서도 다양한 행동 레이어를 계층적으로 관리하기 위해 사용할 수 있음.
