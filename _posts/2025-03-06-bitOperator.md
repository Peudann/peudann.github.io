---
title: "25.03.06 / 비트 연산자를 이용한 2진법 출력"
excerpt: ""

categories:
  - Programming
tags:
  - []

toc: true
toc_sticky: true

date: 2025-03-06
last_modified_at: 2025-04-23
---

아래 코드는 비트 연산자를 이용한 2진법을 8비트로 출력하는 코드이다. 이 코드를 작동 순서에 따라 분석해보자.

```c
#include <stdio.h>

void BitBinary(int n) {
    for (int i = 7; i >= 0; i--) {
        printf("%d", (n >> i) & 1);
    }
}

int main() {
    int num;
    printf("정수를 입력하세요: ");
    scanf("%d", &num);

    printf("2진수 변환: ");
    BitBinary(num);
    printf("\n");

    return 0;
}
```

우선 코드를 실행하면 main 함수가 불러와진다.

```c
int num;
printf("정수를 입력하세요: ");
scanf("%d", &num);
```

이 부분은 사용자에게 정수를 입력받아 변수 num에 저장하는 과정이다.

이번 글에선 예시로 5를 입력받았다고 가정하겠다.

```c
BitBinary(num);
```

입력받은 num은 2진수로 변환하여 출력하는 BitBinary 함수를 실행하게 된다.

```c
void BitBinary(int n) {
    for (int i = 7; i >= 0; i--) {
        printf("%d", (n >> i) & 1);
    }
}
```

BitBinary는 for 반복문을 사용하여 비트 연산을 수행하고 출력하는 함수이다.

입력받은 값이 5인 for 루프의 내부 동작을 알아보겠다.

| i 값 | (n >> i) 결과     | (n >> i) & 1 결과 (최하위 비트와 1의 AND 연산) | 출력 |
| ---- | ----------------- | ---------------------------------------------- | ---- |
| 7    | 5 >> 7 = 00000000 | 0 & 1 = 0                                      | 0    |
| 6    | 5 >> 6 = 00000000 | 0 & 1 = 0                                      | 0    |
| 5    | 5 >> 5 = 00000000 | 0 & 1 = 0                                      | 0    |
| 4    | 5 >> 4 = 00000000 | 0 & 1 = 0                                      | 0    |
| 3    | 5 >> 3 = 00000000 | 0 & 1 = 0                                      | 0    |
| 2    | 5 >> 2 = 00000001 | 1 & 1 = 1                                      | 1    |
| 1    | 5 >> 1 = 00000010 | 0 & 1 = 0                                      | 0    |
| 0    | 5 >> 0 = 00000101 | 1 & 1 = 0                                      | 1    |

i가 7일땐 00000101(2)의 가장 왼쪽인 0, 0일땐 00000101(2)의 가장 오른쪽인 1이 1과 AND 연산을 한다 볼 수 있다. 최종적으로 2진수로 변환하여 출력한 5는 00000101(2)이다.

이번엔 입력받은 값이 -5인 for 루프의 내부 동작을 알아보자.

\-5를 int형(8비트)로 저장하면 2의 보수 형식이 적용된다. -5는 5, 00000101(2)의 2의 보수인 11111011(2)가 된다.

| i 값 | (n >> i) 결과       | (n >> i) & 1 결과 (최하위 비트와 1의 AND 연산) | 출력 |
| ---- | ------------------- | ---------------------------------------------- | ---- |
| 7    | \-5 >> 7 = 11111111 | 1 & 1 = 1                                      | 1    |
| 6    | \-5 >> 6 = 11111111 | 1 & 1 = 1                                      | 1    |
| 5    | \-5 >> 5 = 11111111 | 1 & 1 = 1                                      | 1    |
| 4    | \-5 >> 4 = 11111111 | 1 & 1 = 1                                      | 1    |
| 3    | \-5 >> 3 = 11111111 | 1 & 1 = 1                                      | 1    |
| 2    | \-5 >> 2 = 11111110 | 0 & 1 = 0                                      | 0    |
| 1    | \-5 >> 1 = 11111101 | 1 & 1 = 1                                      | 1    |
| 0    | \-5 >> 0 = 11111011 | 1 & 1 = 1                                      | 1    |

똑같이 i가 7일땐 11111011(2)의 가장 왼쪽인 1, 0일땐 11111011(2)의 가장 오른쪽인 1이 1과 AND 연산을 한다. 최종적으로 2진수로 변환하여 출력한 -5는 11111011(2)이다.

이 코드의 핵심 원리는

1\. 비트 시프트 (>>)를 사용해 특정 위치의 비트를 추출한다. n >> i로 i번째 비트 위치를 최하위 비트로 이동시킨다.

2\. 비트 AND 연산 (& 1)을 사용해 최하위 비트만 추출한다. (n >> i) & 1을 하면 최하위 비트로 이동한 i번째 비트가 0인지 1인지 판별할 수 있다.

3\. 최상위 비트부터 출력한다. for (int i = 7; i >= 0; i--)로 최상위 비트 -> 최하위 비트 순서대로 출력한다.

비트 연산자를 이용한 2진법 출력은 배열을 사용하지 않기 때문에 메모리가 절약되고, 연산 속도가 빠른 것이 장점이다. 그리고 for문의 i값을 15, 31로 조정하여 16비트, 32비트의 2진수도 출력이 가능하다.
