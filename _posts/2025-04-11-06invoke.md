---
title: "25.04.11 / 콜백 함수에서 Invoke를 사용하는 이유"
excerpt: ""

categories:
  - Programming
tags:
  - []

toc: true
toc_sticky: true

date: 2025-04-11
last_modified_at: 2025-04-29
---

우선 콜백 함수(Callback Function)라는 개념부터 간단히 짚어보자.

콜백 함수란, 특정 이벤트가 발생했을 때 미리 등록해둔 함수를 실행하는 기법을 말한다. 예를 들어, "데이터를 다 읽으면 이 함수를 호출할 것"라고 등록해두면, 실제 데이터 처리가 끝난 시점에 함수가 자동으로 호출된다. 이때 콜백 함수가 들고있는 **'스레드'**가 중요한 포인트가 된다.

프로그램 안에는 한 개 이상의 스레드(Thread)가 돌아간다. 여기에는

- UI 스레드(Main Thread): 화면을 그리고, 사용자의 입력을 처리하는 스레드
- 백그라운드 스레드(Worker Thread): 무거운 연산(파일 처리, 네트워크 통신, 계산 등)을 따로 수행하기 위한 보조 스레드

UI 요소(윈도우 폼, 버튼, 텍스트 박스 등)는 UI 스레드에서만 안전하게 접근할 수 있도록 만들어져 있다. 백그라운드 스레드가 직접 UI를 바꿔 버리면 충돌이나 오류가 발생하기 쉬워서, 대부분의 프레임워크가 이를 엄격히 막고 있다.

문제는 콜백 함수가 어느 스레드에서 실행되는지 확실치 않다는 데 있다. 콜백은 일반적으로 다음과 같은 상황에서 불리게 된다.

- 비동기 작업 완료 시점
  - 예: 파일 읽기, 네트워크 요청 등 시간이 오래 걸리는 작업이 끝난 후 콜백 호출
  - 대부분 이런 비동기 작업은 백그라운드 스레드에서 처리된다.
- 시스템/엔진 내부 호출
  - 예: 유니티 엔진 내부에서 특정 이벤트가 발생했을 때 호출, 또는 .NET 라이브러리 내부에서 완료 이벤트 발생 시 호출
  - 어디서 어떻게 호출되는지 우리가 일일이 추적하기 어렵다.

이때 콜백 안에서 "UI"를 갱신해야 하는 일이 있다면 어떻게 해야 할까? 백그라운드 스레드에서 UI를 조작하면 예외가 발생한다. 그래서 "지금 이 일을 UI 스레드한테 시켜줘"라고 요청해야 하는데, 그 역할을 하는게 바로 **Invoke** 메소드이다.

간단한 예시 코드를 보자.

```csharp
private void LoadDataAsync() {
    Task.Run(() => {
        // 여기서는 백그라운드 스레드에서 돌아가고 있음
        string data = SomeLongOperation(); // 오래 걸리는 작업

        // UI에 표시해야 한다면?
        // -> 바로 this.listBox.Items.Add(data); 처럼 쓰면 예외가 날 수 있음
        // -> 그래서 Invoke 사용
        this.Invoke(new Action(() => {
            // 이제 이 블록 안은 UI 스레드가 처리
            listBox.Items.Add(data);
        }));
    });
}
```

Task.Run 내부의 코드는 백그라운드 스레드에서 실행된다. 여기서 UI 관련 작업을 하려면 UI 스레드가 필요하다. 그래서 this.Invoke()를 통해 UI 스레드에게 일을 맡기게 되는 것이다.

정리하자면, 콜백 함수는 언제, 어느 스레드에서 실행될지 예측하기 어려운 경우가 많다. UI 스레드만이 UI 컨트롤을 안전하게 업데이트할 수 있기 때문에, 백그라운드 스레드에서 직접 UI를 건드리는 대신 Invoke를 통해 UI 스레드에게 대신 작업을 부탁해야 하는 것이다.

이것이 우리가 콜백 함수에서 Invoke를 사용하는 이유, 즉 "스레드 간 안정성"을 보장하기 위한 방법이다.
